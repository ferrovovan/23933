## Хорошие вопросы
Всего 13.

1. Как происходит загрузка операционной системы? Что такое первичный загрузчик? Вторичный? Как происходит загрузка бездисковых машин?

2. Драйвер устройства. Функции драйвера в ОС семейства Unix.

7. Уровни RAID.

13. Разделяемая память. Преимущества и недостатки по сравнению с другими методами межпроцессного взаимодействия.

16. Системы управления доступом. Полномочия и списки контроля доступа. Кольца доступа.

24. Определение задачи реального времени. Чем системы РВ отличаются от систем разделенного времени? Пример архитектуры ОС реального времени.

25. Журнальные файловые системы. Принципы работы. Для чего это нужно?

28. Что такое абсолютный и относительный загрузчики? Структура абсолютного и перемещаемого загрузочных модулей. Что такое позиционно-независимый код?

29. Устойчивые к сбоям файловые системы. Методы реализации устойчивых ФС.

32. Сигналы в системах семейства Unix.

34. Программные каналы (трубы) в системах семейства Unix.

38. Механизм setuid в ОС семейства Unix.

40. Права доступа к файлам в ОС семейства Unix.

## Интересные вопросы
Достаточно семи на оценку "хорошо".

1,2,7,25, 32,34,40.

##  Подробные ответы на выбранные вопросы

### 1. Как происходит загрузка операционной системы? Что такое первичный загрузчик? Вторичный? Как происходит загрузка бездисковых машин?

- **Этап 1: Инициализация оборудования.**  
После включения питания центральный процессор запускает код, записанный в ПЗУ, — BIOS (или UEFI). Он выполняет тестирование компонентов системы (POST) и находит устройство, с которого можно загрузить операционную систему.

- **Этап 2: Первичный загрузчик.**  
Это небольшой код, находящийся в загрузочном секторе устройства (обычно первого сектора). Например, в MBR-структуре первые 446 байтов используются под загрузчик. Его задача — загрузить вторичный загрузчик или ядро ОС.

- **Этап 3: Вторичный загрузчик.**  
Обеспечивает сложную начальную конфигурацию: предоставляет пользователю выбор системы (в случае мультизагрузки), загружает ядро и передаёт ему управление. Примеры: GRUB, Syslinux.

- **Этап 4: Инициализация ядра.**  
Ядро загружается в оперативную память, выполняет настройку оборудования, монтирует корневую файловую систему и передаёт управление системным процессам (обычно init).

- **Бездисковые машины.**  
Они используют сетевые протоколы (PXE) для загрузки операционной системы с удалённого сервера. BIOS загружает минимальный образ по сети, который выполняет дальнейшую загрузку.

---

### 2. Драйвер устройства. Функции драйвера в ОС семейства Unix.

Драйвер устройства — это компонент ядра операционной системы, обеспечивающий взаимодействие между аппаратным обеспечением и операционной системой.

**Функции драйвера в Unix:**  
- Управление устройством (инициализация, настройка параметров).
- Обеспечение интерфейса для прикладных программ через системные вызовы.
- Обработка запросов на ввод/вывод.
- Обработка ошибок (например, переполнение буфера).
- Оптимизация использования ресурсов устройства.

Типы драйверов в Unix:
- **Блочные** (для работы с устройствами с произвольным доступом, например, жесткими дисками).
- **Символьные** (для последовательного доступа, например, клавиатура, терминал).

---

### 7. Уровни RAID.

RAID (Redundant Array of Independent Disks) — технология объединения нескольких физических дисков для повышения производительности и/или надёжности.

Основные уровни RAID:
- **RAID 0 (Striping):** Делит данные на части и записывает их на разные диски. Высокая скорость, но отсутствие избыточности.
- **RAID 1 (Mirroring):** Полное дублирование данных. Высокая надёжность, но вдвое увеличивается потребление памяти.
- **RAID 5:** Чередование с избыточностью. Один диск хранит контрольные данные. Хороший баланс производительности и отказоустойчивости.
- **RAID 6:** Подобен RAID 5, но использует два контрольных диска, обеспечивая устойчивость к выходу из строя двух устройств.
- **RAID 10:** Комбинация RAID 1 и RAID 0 (зеркалирование + чередование).

---

### 13. Разделяемая память. Преимущества и недостатки по сравнению с другими методами межпроцессного взаимодействия.

**Разделяемая память** — это метод межпроцессного взаимодействия (IPC), при котором несколько процессов могут одновременно работать с одной и той же областью памяти.

**Преимущества разделяемой памяти:**
- **Быстродействие:**  
  Механизм разделяемой памяти обеспечивает наибольшую производительность, поскольку данные передаются напрямую через общую область памяти, минуя промежуточные буферы и очереди сообщений.
  
- **Экономия ресурсов:**  
  Все процессы могут работать с одним и тем же экземпляром данных, что снижает потребность в копировании данных между процессами, особенно при больших объёмах данных.

- **Простота в использовании:**  
  Используя разделяемую память, можно легко синхронизировать процессы, например, с использованием мьютексов или семафоров для контроля доступа.

**Недостатки разделяемой памяти:**
- **Сложность синхронизации:**  
  Необходимо обеспечить правильный доступ к общей области памяти, например, при использовании мьютексов или семафоров. Несанкционированный доступ может привести к гонкам за ресурс и нестабильности работы программы.
  
- **Безопасность:**  
  Поскольку несколько процессов могут обращаться к общей памяти, без должной защиты существуют риски для безопасности данных. Один процесс может изменить содержимое памяти другого.

- **Сложность управления памятью:**  
  Работа с разделяемой памятью требует настройки прав доступа, а также необходимости очищать ресурсы, что усложняет разработку и управление.

**Сравнение с другими методами IPC:**
- **Сообщения (Message Passing):**  
  В отличие от разделяемой памяти, при передаче сообщений процесс отправляет и получает данные через каналы, что медленнее, но безопаснее, так как исключает прямой доступ к общей памяти.
  
- **Трубопроводы (Pipes):**  
  Механизм трубы используется для передачи данных между двумя процессами, часто через файловую систему, что обычно медленнее, чем разделяемая память.

---

### 16. Системы управления доступом. Полномочия и списки контроля доступа. Кольца доступа.

**Системы управления доступом (СУД)** — это механизм, позволяющий контролировать доступ пользователей или процессов к различным объектам системы (файлам, ресурсам).

**Полномочия** — это разрешения, определяющие, какие действия может выполнить пользователь или процесс с объектом системы. Например, для файла полномочия могут включать права на чтение, запись и выполнение.

**Списки контроля доступа (ACL)** — это таблицы, которые содержат информацию о правах доступа для каждого пользователя или группы пользователей. Каждому ресурсу в системе (файлу, процессу) может быть присвоен список, содержащий правила доступа для различных субъектов.

**Кольца доступа:**
- **Кольца безопасности** — это концепция в ОС для управления привилегиями процесса.
- В некоторых системах (например, в x86 архитектуре) существует несколько колец, каждое из которых имеет свой уровень привилегий:
  - **Кольцо 0 (Ring 0):** Это самое привилегированное кольцо, в котором работает ядро операционной системы. Процессы в этом кольце имеют полный доступ ко всем аппаратным ресурсам.
  - **Кольцо 1 и 2 (Ring 1, Ring 2):** Используются для драйверов устройств и менее привилегированных системных процессов.
  - **Кольцо 3 (Ring 3):** Это кольцо для пользовательских приложений, которые не имеют прямого доступа к аппаратным ресурсам и должны использовать системные вызовы для выполнения операций.
  
Механизм колец позволяет разделить привилегии процессов и тем самым минимизировать риски для безопасности системы.

---

### 24. Определение задачи реального времени. Чем системы реального времени отличаются от систем разделённого времени? Пример архитектуры ОС реального времени.

**Задача реального времени** — это задача, в которой выполнение или результат должен быть получен в строго ограниченный момент времени или в пределах заданного временного окна. Основная цель — выполнить операции в нужный момент, гарантируя выполнение внутри критических временных рамок.

**Системы реального времени** (СРВ) имеют два типа:  
1. **Жёсткие системы реального времени** — задачи должны быть выполнены до строго определённого момента (например, управление ядерной реакторной установкой или навигационными системами).
2. **Мягкие системы реального времени** — задачи должны быть выполнены в пределах заданного интервала времени, но иногда могут и опоздать (например, потоковое видео или передача данных).

**Отличия от систем разделённого времени:**
- **Системы реального времени** должны гарантировать, что каждая задача будет выполнена в строго заданный временной интервал, независимо от других процессов и задач.
- **Системы разделённого времени** предоставляют процессам доступ к процессору по очереди с предсказуемым временем выполнения, но задачи не обязаны завершаться в жёстко заданное время. Это более адаптивные системы, и они могут отклоняться от критических временных требований.

**Архитектура ОС реального времени:**
- ОС реального времени использует жёсткие приоритеты для выполнения задач с ограничением времени. Планировщик находит оптимальный момент для выполнения задачи в зависимости от её приоритетов и временных ограничений.
- Пример: **RTLinux**, **VxWorks**, **QNX** — операционные системы, которые включают в себя механизмы обработки прерываний с жёсткими ограничениями на время выполнения задач.

---

### 25. Журнальные файловые системы. Принципы работы. Для чего это нужно?

Журнальные файловые системы ведут специальный журнал, в который записывают изменения перед их применением. Это обеспечивает устойчивость к сбоям.

**Принципы работы:**
- Все операции с файлами сначала записываются в журнал.
- Если система внезапно отключается, она может восстановить состояние из журнала.
- Журнал удаляется, когда операция завершается.

**Преимущества:**
- Уменьшает вероятность повреждения данных из-за сбоев.
- Быстрое восстановление после сбоев.

Примеры: Ext3, Ext4, NTFS.

---

### 28. Что такое абсолютный и относительный загрузчики? Структура абсолютного и перемещаемого загрузочных модулей. Что такое позиционно-независимый код?

**Абсолютный и относительный загрузчики:**

- **Абсолютный загрузчик:**  
Требует, чтобы загрузочный файл находился в строго определённом адресе в памяти. Он не может быть перемещен во время выполнения программы, так как все адреса жестко зафиксированы на момент компиляции.
  
- **Относительный загрузчик:**  
Позволяет загружать и исполнять программу в произвольном месте памяти, так как он использует относительные адреса для обращения к данным и коду, что делает его более гибким по сравнению с абсолютным загрузчиком.

**Структура абсолютного и перемещаемого загрузочных модулей:**
- **Абсолютный модуль:**  
Модуль всегда загружается в конкретное место в памяти. Адреса в модуле всегда фиксированы.
  
- **Перемещаемый модуль:**  
Код может быть загружен в любой участок памяти, поскольку все адреса указаны относительно некоторого базового адреса, а не непосредственно фиксированны. Такой код требует установки начальных адресов и переписывания меток после загрузки, чтобы система могла использовать данные по новому адресу.

**Позиционно-независимый код (PIC):**
Позиционно-независимый код является кодом, который может быть загружен в любой участок памяти без необходимости модификации адресов в коде при его загрузке. Используется в динамических библиотеках, так как она может быть загружена в любое место памяти. Позиционно-независимые программы используют специальные регистры для управления смещениями адресов.

---

### 29. Устойчивые к сбоям файловые системы. Методы реализации устойчивых ФС.

**Устойчивые к сбоям файловые системы** обеспечивают сохранность данных, даже если происходит сбой в процессе записи, система зависает или происходит потеря питания.

**Методы реализации устойчивых файловых систем:**
- **Журналирование (Journaling):**  
Файловая система записывает метаданные о предполагаемых изменениях в специальный журнал до того, как применит эти изменения. В случае сбоя система может использовать журнал для восстановления данных в корректном состоянии. Примеры: Ext3, Ext4, NTFS.
  
- **Контрольные точки и восстановление (Checkpointing and Rollback):**  
ФС регулярно сохраняет контрольные точки, что позволяет при сбое восстановить данные до последней консистентной точки. После сбоя система восстанавливает состояние, анализируя журнал или контрольные точки.

- **Репликация:**  
Данные копируются на несколько устройств, что повышает надежность и защищает от потери данных. Пример: RAID-массивы.

- **Использование средств коррекции ошибок:**  
Некоторые файловые системы используют методы для обнаружения и исправления ошибок (например, при помощи избыточности данных).

**Преимущества:**
- Повышенная отказоустойчивость.
- Быстрое восстановление после сбоев.
  
**Недостатки:**
- Повышенная нагрузка на систему из-за журналирования.
- Потери в производительности при больших объёмах данных.

---

### 32. Сигналы в системах семейства Unix.

Сигналы — это механизм межпроцессного взаимодействия, позволяющий ОС уведомлять процесс о событиях.

**Основные сигналы:**
- `SIGKILL`: Принудительное завершение процесса (не может быть обработан).
- `SIGTERM`: Обычное завершение процесса.
- `SIGHUP`: Перезапуск.
- `SIGSEGV`: Нарушение сегментирования.
- `SIGINT`: Прерывание с клавиатуры (Ctrl+C).

**Обработка сигналов:**
Процесс может назначить обработчики для сигналов, использовав функции `signal` или `sigaction`.

### 34. Программные каналы (трубы) в системах семейства Unix.

**Программные каналы (трубы)** в Unix-системах представляют собой механизм межпроцессного взаимодействия (IPC), который позволяет передавать данные между процессами через виртуальный канал. Канал работает как однонаправленная линия связи между двумя процессами, и данные, записанные одним процессом, могут быть считаны другим процессом.

В Unix-системах различают два типа труб:
1. **Анонимные трубы (Anonymous Pipes)** — это каналы, которые существуют только в контексте родственного отношения между процессами (например, между родительским и дочерним процессами). Анонимные трубы обычно используют при выполнении команд в конвейере (pipe).
   
2. **Именованные трубы (Named Pipes или FIFO)** — это каналы, которые могут быть использованы любыми процессами, которые могут обратиться к ним по имени, обычно через файловую систему. Именованные трубы позволяют более гибко передавать данные между независимыми процессами, которые могут находиться в различных родственных или управляемых контекстах.

**Механизм работы труб:**
- Труба создается как часть процесса или с использованием системного вызова. Процесс может записывать данные в один конец трубы (вход), и эти данные могут быть прочитаны другим процессом через другой конец трубы (выход).
  
- Каналы обычно характеризуются асинхронностью и буферизацией, где данные передаются по одному потоку, что позволяет эффективно осуществлять обмен информации между процессами.

- Несмотря на свой парадигм, трубы являются однонаправленными, то есть данные могут двигаться только в одном направлении. Для двусторонней передачи информации требуется использование двух труб.

**Сильные стороны труб:**
- Простота использования для обмена небольшими объемами данных между процессами.
- Экономичность ресурсов системы, так как не требуется использование дополнительных средств синхронизации.

**Ограничения труб:**
- Однонаправленность передачи данных.
- Применение труб ограничено областью процесса (в случае анонимных труб) или необходимостью соответствующих прав доступа (в случае именованных труб).
  
Трубы являются удобным механизмом для обмена данными между процессами в Unix-системах, позволяя решить задачу IPC эффективно и с минимальной нагрузкой на систему.


### 38. Механизм setuid в ОС семейства Unix.

**setuid** (set user ID) — это системный вызов в UNIX-подобных операционных системах, который позволяет процессу получить права другого пользователя. Обычно используется в ситуациях, когда программа, запускаемая обычным пользователем, должна выполнить действия, требующие прав администратора (например, доступ к сетевым ресурсам или файлам, ограниченным для обычных пользователей).

**Как работает setuid:**
- Если процесс с правами обычного пользователя использует setuid для выполнения программы, программа может выполнять операции с правами пользователя, для которого она была предназначена.
- Обычно этот механизм используется для реализации утилит с повышенными правами, таких как `passwd` или `sudo`, которые должны изменять системные настройки от имени суперпользователя (root), но при этом пользователи могут выполнять их, не будучи администратором.

**Пример:** Программа, изменяющая пароль, может использовать setuid для получения прав пользователя root для записи в защищённые системные файлы, при этом сам пользователь не будет иметь прав администратора.

Механизм **setuid** обеспечивает безопасное использование привилегий без необходимости предоставлять пользователю полный доступ к правам суперпользователя.

---

### 40. Права доступа к файлам в ОС семейства Unix

**Права доступа к файлам** в операционных системах семейства Unix определяют, кто и какие операции может выполнять с конкретными файлами и каталогами. Эти права используются для обеспечения безопасности системы и контроля над доступом.

**Основные категории прав доступа**:

1. **Пользователь** (User) — владелец файла. Это физическое лицо или процесс, который создал файл или был назначен владельцем.
2. **Группа** (Group) — группа, к которой относится файл. Каждый файл или каталог может быть связан с определенной группой, и члены этой группы могут иметь определенные права доступа.
3. **Прочие** (Other) — все остальные пользователи системы, не являющиеся владельцами и не входящие в группу владельца.

Кроме традиционных разделений на пользователя, группу и остальных,
в Unix-подобных системах имеется дополнительная многослойная структура прав доступа,
включающая в себя системные аккаунты,
дополнительные атрибуты и механизмы безопасности (setuid, setgid, ACL, и т. д.),
которые обеспечивают более тонкую настройку управления доступом и безопасности.

**Типы прав доступа:**

1. **Чтение (r)** — право на просмотр содержимого файла или каталога.
Для файлов это позволяет просматривать текст или данные файла.
Для каталогов — просматривать имена файлов в каталоге.
2. **Запись (w)** — право изменять содержимое файла или добавлять и удалять файлы в каталоге.
Для файлов это позволяет редактировать их данные,
для каталогов — добавлять или удалять файлы.
3. **Исполнение (x)** — право на выполнение файла как программы или скрипта.
Для файлов с исполняемыми программами это даёт возможность запуска.
Для каталогов это право позволяет входить в каталог и обращаться к его содержимому.

**Формат представления прав доступа:**
Права доступа к файлу отображаются с помощью 10 символов.
Стандартный вывод для прав доступа выглядит так:
```
ls -l
-rwxr-xr-- 1 user group 1234 дек 22 2024 file
```

- Первый символ указывает на тип файла:
  - `-` для обычного файла.
  - `d` для директории.
  - `l` для символической ссылки.

- Следующие 9 символов разбиваются на 3 группы по 3 символа:
  1. Права владельца (User),
  2. Права группы (Group),
  3. Права других пользователей (Other).

В каждой группе из 3 символов используются:
- `r` — право на чтение,
- `w` — право на запись,
- `x` — право на выполнение.

**Системные вызовы и утилиты**:
- Для изменения прав доступа используется командой `chmod`. Это позволяет задавать и изменять права доступа как для владельца, так и для группы и прочих пользователей.
  
- Утилита `chown` позволяет изменять владельца и группу файла.
  
- Утилита `umask` используется для задания маски прав доступа при создании новых файлов, ограничивая разрешенные права для новых объектов.

**Важность прав доступа**:
- Права доступа являются ключевым элементом системы безопасности в Unix-подобных операционных системах.
С их помощью контролируется доступ к системным и пользовательским данным,
предотвращая несанкционированное чтение, изменение или выполнение файлов.

- Для предотвращения случайных или злонамеренных действий важно правильно настраивать права доступа,
особенно для важных файлов системы,таких как
конфигурационные файлы, исполнимая информация или журналы системы.

В системе Unix существующие права доступа,
и механизм управления ими играют решающую роль в управлении безопасностью и контроле доступа к ресурсам.

